# 코틀린의 기본 요소: 함수와 변수

## 1. 코틀린 함수 소개
코틀린에서 함수는 'fun' 키워드로 시작한다. 함수 선언 시 주요 특징은 다음과 같다.
- 반환 타입을 생략할 수 있다.
- 함수를 클래스 외부에 정의할 수 있다.
- 매개변수 이름 뒤에 타입을 지정한다.

## 2. 코틀린 변수 이해하기
코틀린에서 변수는 'val'과 'var'로 선언한다.
- 'val': 불변(immutable) 변수
- 'var': 가변(mutable) 변수

## 3. 코틀린의 특별한 기능
- 타입 추론: 변수와 함수의 반환 타입을 자동으로 추론한다.
- 문자열 템플릿: 문자열 내에 변수나 표현식을 쉽게 삽입할 수 있다.

---
# 코틀린의 클래스와 객체

코틀린에서는 클래스와 객체를 더욱 간결하고 효율적으로 정의한다. 이는 자바와 비교했을 때 큰 장점 중 하나이다.

## 1. 클래스 정의의 간소화
- 코틀린에서는 클래스를 정의할 때 생성자와 프로퍼티를 한 줄로 선언한다. 이는 자바에서 필요한 여러 줄의 코드를 대체한다.

## 2. 프로퍼티 접근자
- 코틀린은 기본적으로 getter와 setter를 자동으로 생성한다. 필요한 경우 커스텀 접근자를 정의할 수 있다.

## 3. 패키지와 임포트
- 코틀린의 패키지 선언과 임포트 문은 자바와 유사하지만, 최상위 함수의 임포트가 가능하다.

## 4. 파일 구조의 유연성
- 코틀린에서는 하나의 파일에 여러 클래스, 함수, 최상위 변수를 선언할 수 있어 관련 코드를 함께 관리하기 용이하다.
- 이러한 특징들로 인해 코틀린은 더 간결하고 표현력 있는 코드 작성을 가능하게 한다.

---
# 코틀린의 제어 구조와 표현식 처리

코틀린은 강력한 제어 구조와 표현식 처리 기능을 제공한다. 특히 'when'과 'enum'은 매우 유용한 기능이다.

## enum 클래스

enum 클래스는 상수 집합을 정의하는 데 사용한다. 코틀린의 enum은 자바와 유사하지만 더 많은 기능을 제공한다.

## when 표현식

when은 코틀린의 강력한 제어 구조로, 자바의 switch문을 대체하고 확장한다.

when은 enum 클래스뿐만 아니라 다양한 타입과 조건에 사용할 수 있다.

## 스마트 캐스트

코틀린의 스마트 캐스트 기능은 타입 검사와 캐스팅을 자동으로 수행한다.

이러한 기능들을 통해 코틀린은 더 간결하고 안전한 코드 작성을 가능하게 한다.

---
# 코틀린의 반복문

코틀린의 반복문은 Java와 유사한 구조를 가진다. 특히 while 문은 거의 동일한 형태를 보인다. 코틀린에서는 주로 while, do-while, 그리고 for 문을 사용하여 반복 작업을 수행한다.

## while과 do-while 반복문

while과 do-while 문의 기본 구조는 다음과 같다:

```kotlin
while (조건) {
    // 코드 블록
}

do {
    // 코드 블록
} while (조건)
```

## for 반복문

코틀린의 for 문은 범위(range)를 사용하여 반복을 수행한다. 다음은 for 문의 예시이다:

```kotlin
fun main() {
    // 1부터 100까지 반복
    for (i in 1..100) {
        println(if (i % 2 == 0) "짝수" else "홀수")
    }

    // 100부터 1까지 3씩 감소하며 반복
    for (i in 100 downTo 1 step 3) {
        println(if (i % 2 == 0) "짝수" else "홀수")
    }
}
```

기본적으로 'i in 1..100'은 양쪽 끝을 포함한다. 마지막 숫자를 제외하려면 'until' 키워드를 사용할 수 있다.

## 컬렉션과 맵의 반복

코틀린에서는 컬렉션과 맵을 쉽게 순회할 수 있다. 다음은 맵을 사용한 예시이다:

```kotlin
val students = mutableMapOf(1 to "Alice", 2 to "Bob", 3 to "Charlie")

for ((num, name) in students) {
    println("번호: $num, 이름: $name")
}
```

여기서 '(num, name) in students'는 맵의 키-값 쌍을 분해하여 각각의 변수에 할당하는 구조 분해 선언을 사용한다.

## 범위 검사

코틀린에서는 'in' 키워드를 사용하여 값이 특정 범위 내에 있는지 쉽게 확인할 수 있다:

```kotlin
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
fun isDigit(c: Char) = c in '0'..'9'

fun recognize(c: Char) = when(c) {
    in '0'..'9' -> "숫자"
    in 'a'..'z', in 'A'..'Z' -> "알파벳"
    else -> "기타 문자"
}
```

이러한 범위 검사는 내부적으로 'a ≤ x ≤ b'와 같은 비교 연산으로 변환된다.

---
# 코틀린의 예외 처리
코틀린의 예외 처리는 자바와 유사하지만, 중요한 차이점이 있다.

## 기본적인 예외 발생
코틀린에서는 자바와 달리 'new' 키워드 없이 예외를 생성할 수 있다.

## try-catch-finally 구문
코틀린의 try-catch-finally 구문은 표현식으로 사용될 수 있어, 값을 반환할 수 있다.

## 자바와의 주요 차이점
코틀린에서는 checked exception을 명시적으로 선언하지 않아도 된다. 이는 편리하지만, 예외 처리에 주의가 필요하다.

## Kotlin과 Spring에서의 @Transactional 사용 시 주의사항
코틀린에서 CheckedException은 기본적으로 롤백되지 않는다. 자바에서는 컴파일러가 이를 강제하지만, 코틀린에서는 개발자가 직접 관리해야 한다.

자바의 경우
- 컴파일러가 checked exception을 처리하도록 강제한다.
- 예외 처리가 명시적으로 이루어진다.

코틀린의 경우
- 명시적인 예외 선언이 없어 놓칠 수 있다.
- 예외가 발생해도 롤백되지 않을 수 있다.
- 중요한 지점에서는 try-catch 블록을 사용하는 것이 좋다.

---
# 함수 호출의 개선된 방식

## 명명된 매개변수
코틀린에서는 함수 호출 시 매개변수의 이름을 지정할 수 있어, 코드의 가독성이 향상된다.
## 기본 매개변수 값
코틀린 함수는 매개변수에 기본값을 지정할 수 있어, 함수 오버로딩의 필요성을 줄여준다.

## 최상위 함수와 프로퍼티
코틀린에서는 함수와 변수를 클래스 외부에 선언할 수 있어, 불필요한 유틸리티 클래스를 만들 필요가 없다.