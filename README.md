# 코틀린의 기본 요소: 함수와 변수

## 코틀린 함수 소개
코틀린에서 함수는 'fun' 키워드로 시작한다. 함수 선언 시 주요 특징은 다음과 같다.
- 반환 타입을 생략할 수 있다.
- 함수를 클래스 외부에 정의할 수 있다.
- 매개변수 이름 뒤에 타입을 지정한다.

## 코틀린 변수 이해하기
코틀린에서 변수는 'val'과 'var'로 선언한다.
- 'val': 불변(immutable) 변수
- 'var': 가변(mutable) 변수

## 코틀린의 특별한 기능
- 타입 추론: 변수와 함수의 반환 타입을 자동으로 추론한다.
- 문자열 템플릿: 문자열 내에 변수나 표현식을 쉽게 삽입할 수 있다.

---
# 코틀린의 클래스와 객체

코틀린에서는 클래스와 객체를 더욱 간결하고 효율적으로 정의한다. 이는 자바와 비교했을 때 큰 장점 중 하나이다.

## 클래스 정의의 간소화
- 코틀린에서는 클래스를 정의할 때 생성자와 프로퍼티를 한 줄로 선언한다. 이는 자바에서 필요한 여러 줄의 코드를 대체한다.

## 프로퍼티 접근자
- 코틀린은 기본적으로 getter와 setter를 자동으로 생성한다. 필요한 경우 커스텀 접근자를 정의할 수 있다.

## 패키지와 임포트
- 코틀린의 패키지 선언과 임포트 문은 자바와 유사하지만, 최상위 함수의 임포트가 가능하다.

## 파일 구조의 유연성
- 코틀린에서는 하나의 파일에 여러 클래스, 함수, 최상위 변수를 선언할 수 있어 관련 코드를 함께 관리하기 용이하다.
- 이러한 특징들로 인해 코틀린은 더 간결하고 표현력 있는 코드 작성을 가능하게 한다.

---
# 코틀린의 제어 구조와 표현식 처리

코틀린은 강력한 제어 구조와 표현식 처리 기능을 제공한다. 특히 'when'과 'enum'은 매우 유용한 기능이다.

## enum 클래스

enum 클래스는 상수 집합을 정의하는 데 사용한다. 코틀린의 enum은 자바와 유사하지만 더 많은 기능을 제공한다.

## when 표현식

when은 코틀린의 강력한 제어 구조로, 자바의 switch문을 대체하고 확장한다.

when은 enum 클래스뿐만 아니라 다양한 타입과 조건에 사용할 수 있다.

## 스마트 캐스트

코틀린의 스마트 캐스트 기능은 타입 검사와 캐스팅을 자동으로 수행한다.

이러한 기능들을 통해 코틀린은 더 간결하고 안전한 코드 작성을 가능하게 한다.

---
# 코틀린의 반복문

코틀린의 반복문은 Java와 유사한 구조를 가진다. 특히 while 문은 거의 동일한 형태를 보인다. 코틀린에서는 주로 while, do-while, 그리고 for 문을 사용하여 반복 작업을 수행한다.

## while과 do-while 반복문

while과 do-while 문의 기본 구조는 다음과 같다:

```kotlin
while (조건) {
    // 코드 블록
}

do {
    // 코드 블록
} while (조건)
```

## for 반복문

코틀린의 for 문은 범위(range)를 사용하여 반복을 수행한다. 다음은 for 문의 예시이다:

```kotlin
fun main() {
    // 1부터 100까지 반복
    for (i in 1..100) {
        println(if (i % 2 == 0) "짝수" else "홀수")
    }

    // 100부터 1까지 3씩 감소하며 반복
    for (i in 100 downTo 1 step 3) {
        println(if (i % 2 == 0) "짝수" else "홀수")
    }
}
```

기본적으로 'i in 1..100'은 양쪽 끝을 포함한다. 마지막 숫자를 제외하려면 'until' 키워드를 사용할 수 있다.

## 컬렉션과 맵의 반복

코틀린에서는 컬렉션과 맵을 쉽게 순회할 수 있다. 다음은 맵을 사용한 예시이다:

```kotlin
val students = mutableMapOf(1 to "Alice", 2 to "Bob", 3 to "Charlie")

for ((num, name) in students) {
    println("번호: $num, 이름: $name")
}
```

여기서 '(num, name) in students'는 맵의 키-값 쌍을 분해하여 각각의 변수에 할당하는 구조 분해 선언을 사용한다.

## 범위 검사

코틀린에서는 'in' 키워드를 사용하여 값이 특정 범위 내에 있는지 쉽게 확인할 수 있다:

```kotlin
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
fun isDigit(c: Char) = c in '0'..'9'

fun recognize(c: Char) = when(c) {
    in '0'..'9' -> "숫자"
    in 'a'..'z', in 'A'..'Z' -> "알파벳"
    else -> "기타 문자"
}
```

이러한 범위 검사는 내부적으로 'a ≤ x ≤ b'와 같은 비교 연산으로 변환된다.

---
# 코틀린의 예외 처리
코틀린의 예외 처리는 자바와 유사하지만, 중요한 차이점이 있다.

## 기본적인 예외 발생
코틀린에서는 자바와 달리 'new' 키워드 없이 예외를 생성할 수 있다.

## try-catch-finally 구문
코틀린의 try-catch-finally 구문은 표현식으로 사용될 수 있어, 값을 반환할 수 있다.

## 자바와의 주요 차이점
코틀린에서는 checked exception을 명시적으로 선언하지 않아도 된다. 이는 편리하지만, 예외 처리에 주의가 필요하다.

## Kotlin과 Spring에서의 @Transactional 사용 시 주의사항
코틀린에서 CheckedException은 기본적으로 롤백되지 않는다. 자바에서는 컴파일러가 이를 강제하지만, 코틀린에서는 개발자가 직접 관리해야 한다.

자바의 경우
- 컴파일러가 checked exception을 처리하도록 강제한다.
- 예외 처리가 명시적으로 이루어진다.

코틀린의 경우
- 명시적인 예외 선언이 없어 놓칠 수 있다.
- 예외가 발생해도 롤백되지 않을 수 있다.
- 중요한 지점에서는 try-catch 블록을 사용하는 것이 좋다.

---
# 함수 호출의 개선된 방식

## 명명된 매개변수
코틀린에서는 함수 호출 시 매개변수의 이름을 지정할 수 있어, 코드의 가독성이 향상된다.
## 기본 매개변수 값
코틀린 함수는 매개변수에 기본값을 지정할 수 있어, 함수 오버로딩의 필요성을 줄여준다.

## 최상위 함수와 프로퍼티
코틀린에서는 함수와 변수를 클래스 외부에 선언할 수 있어, 불필요한 유틸리티 클래스를 만들 필요가 없다.

---
# **확장** **함수**(Extension function)**와** **확장** **프로퍼티**(Extension property)

## 확장 함수 (Extension Function)

기존 클래스에 새로운 메서드를 추가하는 기능

- 장점: 라이브러리 클래스를 쉽게 확장 가능
- 제한: 오버라이드 불가 (내부적으로 정적 메서드로 구현)

## 확장 프로퍼티 (Extension Property)
기존 클래스에 새로운 프로퍼티를 추가하는 기능

## 컬렉션의 확장 함수
Set, List 등 컬렉션에 추가 기능을 제공

## 가변 인자 함수
vararg 키워드를 사용해 가변적인 개수의 인자를 받는 함수

## 중위 호출 (Infix Function)
확장 함수이면서 파라미터가 하나인 함수에 사용 가능
- 주로 mapOf("key" to "value")와 같은 형태로 사용

## 구조 분해 선언 (Destructuring Declarations)
Pair, Triple, 또는 데이터 클래스의 속성을 개별 변수로 분해

이러한 기능들은 코드의 가독성을 향상시키고, 더 간결하고 표현력 있는 코드 작성을 가능

---
# 코틀린의 클래스, 객체, 인터페이스 활용

## 인터페이스와 구현
코틀린에서는 인터페이스 구현 시 콜론(:)을 사용합니다. 또한, 메서드 구현 시 'override' 키워드를 반드시 사용해야 합니다.

## 다중 인터페이스 구현
여러 인터페이스를 동시에 구현할 때, 동일한 이름의 메서드가 존재하면 명시적으로 구현을 제공해야 합니다.

## 변경자: open, final, abstract
코틀린에서는 기본적으로 모든 클래스와 메서드가 final입니다. 이는 무분별한 상속을 방지하고 코드의 안정성을 높이는 데 도움이 됩니다.
상속이 필요한 경우, 'open' 키워드를 사용합니다.

## 가시성 변경자
코틀린의 가시성 변경자는 다음과 같습니다.
- public (기본값): 어디서나 접근 가능
- private: 같은 클래스 또는 파일 내에서만 접근 가능
- protected: 하위 클래스에서만 접근 가능
- internal: 같은 모듈 내에서만 접근 가능

코틀린은 자바와 달리 기본 가시성이 public이며, 패키지 전용 가시성이 없습니다. 대신 모듈 내부에서만 볼 수 있는 internal 가시성을 제공합니다.
---
## 봉인된 클래스 (Sealed Class)

확장을 제한하여 편의성을 향상시키는 클래스 타입입니다. 컴파일러가 모든 하위 클래스를 알 수 있어 when 구문에서 else 분기가 불필요합니다.

## 생성자와 초기화
- 주 생성자 (Primary Constructor): 클래스 선언 시 가장 간단한 형태로 사용
- 초기화 블록 (Init Block): 객체 생성 시 프로퍼티 초기화에 사용
- 부 생성자 (Secondary Constructor): 여러 생성자를 제공할 때 사용

## 프로퍼티와 접근자
getter와 setter를 커스터마이징할 수 있으며, backing field를 통해 프로퍼티에 접근합니다. private set을 사용하여 setter의 가시성을 제한할 수 있습니다.

## Data Class
데이터 저장 용도의 클래스로, toString(), equals(), hashCode() 등의 메서드를 자동으로 제공합니다.

## Object 키워드
싱글톤 패턴을 구현하거나 익명 클래스를 생성할 때 사용합니다.

## Companion Object
자바의 static 멤버를 대체하는 용도로 사용되며, 클래스 내부에 정의됩니다.
---
# 코틀린 람다식 개요
람다식은 코틀린에서 함수를 간결하게 표현하는 방법입니다. 주요 특징은 다음과 같습니다:

- 작은 코드 조각으로, 함수에 로직을 전달할 때 주로 사용
- 코틀린 컬렉션에서 자주 활용되어 코드를 간결하게 만듦
- Java에 비해 더 간단한 문법 제공

## 람다식의 장점
- 높은 가독성과 간결성
- 함수형 프로그래밍 지원
- 컬렉션 조작 시 유용

## 람다식 문법
기본 형태: { 파라미터 -> 본문 }

예시: val sum = { x: Int, y: Int -> x + y }

## 람다식 사용 방법
- 함수 파라미터로 전달
- 변수에 저장하여 나중에 실행

## 컬렉션 함수형 API

주요 함수
- filter: 데이터 필터링
- map: 데이터 변환
- all, any, count, find: 조건 검사 및 요소 찾기
- groupBy: 그룹화
- flatMap, flatten: 중첩 컬렉션 처리

## sequence
대량 컬렉션 처리 시 유용한 기능으로, 필요한 경우에만 계산을 수행하여 효율성을 높입니다.

람다식을 활용하면 for, while 루프 없이도 대부분의 컬렉션 조작이 가능하며, 코드의 가독성과 효율성을 크게 향상시킬 수 있습니다.
